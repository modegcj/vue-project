webpack gulp/grunt:
webpack是一种模块化的解决方案，Gulp/Grunt是一种能够优化前端的开发流程的工具，webpack在很多场景下可以替代Gulp/Grunt类的工具

webpack安装:
全局：
npm insatll -g webpck
安装到项目目录:
npm insatll --save-dev webpack

使用详情:
新建一个空的练习文件夹（webpack sample project）
1.使用npm init命令自动创建package.json文件
2.安装webpack作为依赖包
npm install --save-dev webpack
index.html --放在public文件夹中
Greeter.js --放在app文件夹中
main.js --放在app文件夹中

在index.html文件夹中写入最基础的html代码，它在这里目的在于引入打包后的js文件（bundle.js）
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
        <head>
                <meta charset="utf-8">
                <title>Webpack Sample Project</title>
        </head>
        <body>
                <div id="root"></div>
                <script src="bundle.js"></script>
        </body>
</html>
我们在Greeter.js中定义一个返回包含问候信息的html元素的函数，并依据CommonJS规范导出这个函数为一个模块：
//Greeter.js
module.exports = function(){
        var greet = document.createElement('div');
        greet.textContext = 'Hi Webpack';
        return greet;
}
main.js文件中我们写入下述代码，用以把Greeter模块返回的节点插入页面。
//
const greeter = require('./Greeter.js')；
document.querySelector("#root").appendChild(greeter());


正式使用Webpack:
（1）webpack 可以在终端中使用，在基本的使用方法如下：

# {entry file}处填写入口文件的路径，本文中就是上述main.js的路径，
# {destination for bundled file}处填写打包文件的存放路径
# 填写路径的时候不用添加{}
webpack   {entry file}   {destination for bundled file}

 * 指定入口文件后，webpack将自动识别项目所依赖的其他文件，不过需要注意的是如果你的webpack不是全局安装的，那么当你在
   终端中使用此命令时，需要额外指定其在node_modules中的地址，继续上面的例子，在终端中输入如下命令
# webpack非全局安装的情况
node_modules/.bin/webpack   app/main.js    public/bundle.js

（2）通过配置文件来使用Webpack

在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，写入如下所示的简单配置代码
module.exports = {
        entry: __dirname + "/app/main.js",
        output: {
                path: __dirname + "/public",
                filename: "bundle.js"
        }
}
有了这个配置之后，再打包文件，只需要在终端里运行webpack(非全局安装需使用node_modules/.bin/webpack)命令就可以了，这条
命令会自动引用webpack.config.js文件中的配置选项

（3）更快捷的执行打包任务

npm可以引导任务执行，对npm进行配置后可以在命令行中使用简单的npm start命令来替代上面略微繁琐的命令。在package.json中对
scripts对象进行相关配置即可，设置方法如下。
{
        "name": "webpack-sample-project",
        "version": "1.0.0",
        "description": "Sample webpack project",
        "scripts": {
                "start": "webpack" //修改此处，JSON文件不支持注释，引用时请清除
        },
        "author": "gaomode",
        "license": "ISC",
        "devDependencies": {
                "webpack": "3.10.0"
        }
}
npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称
不是start，想要在命令中运行时，需要这样用npm run {script name}如npm run build

Webpack的强大功能
（1）生成Source Maps（使调试更容易，使出错了的地方对应写的代码的位置）
在webpack的配置文件中配置source maps，需要配置devtool，它有以下四种不同的配置选项，各具优缺点
1.source-map  在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是他会减慢打包速度
2.cheap-module-source-map  在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到
                                               具体行，不能对应到具体的列（符号），会对调试造成不便；
3.eval-source-map  使用eval打包源文件模块，在同一个文件中生成干净的完整的source map，这个选项可以在不影响构建速度的前提下生成完整source map
                               但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；
4.cheap-module-eval-source-map  这是在打包文件时最快生成source map的方法，生成的Source Map会和打包后的JavaScript文件同行显示，没有列映射
                                                      和eval-source-map选项具有相似的缺点；
对小到中型的项目中，eval-source-map是一个很好的选项，再次强调你只应该开发阶段使用它，我们继续对上文新建的webpack.config.js，进行如下的配置：
module.exports = {
        devtool: 'eval-source-map',
        entry: __dirname + '/app/main.js',
        output: {
                path: __dirname + 'public',
                filename: 'bundle.js'
        }
}
cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑时间成本时使用

（2）使用webpack构建本地服务器（热更新）
安装依赖包
npm install --save-dev webpack-dev-server
devserver的配置选项:
1.contentBase  默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到"public"目录）
2.port  设置默认监听端口，默认"8080"
3.inline  设置为true，当源文件改变时会自动刷新页面
4.historyApiFallback  在开发单页面应用时非常有用，他依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html
例：
module.exports = {
        devtool:'eval-source-map',
        entry:__dirname + "/app/main.js",
        output:{
                path:__dirname + "/public"
                filename: "bundle.js"
        },
        devServer:{
                contentBase: "./public",  //本地服务器所加载的页面的所在目录
                historyApiFallback: true,  //不跳转
                inline:true  //实时刷新
        }
}
在package.json中的scripts对象中添加如下命令，用以开启本地服务器：
"scripts":{
        "test":"echo \"Error: no test specified\" && exit i",
        "start": "webpack",
        "server": "webpack-dev-server --open"
}

（3）loaders
通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的js文件(ES6,ES7)转换为现代浏览器兼容的JS文件，
对React的开发而言，合适的loaders可以把React中用的JSX文件转换为JS文件。
loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，loaders的配置包括以下几方面：
（*为必填）
1.test: 一个用以匹配loaders所处理文件的拓展名的正则表达式 *
2.loader:loader的名称 *
3.include/exclude:手动添加必须处理的文件（文件夹）/屏蔽不需要处理的文件（文件夹）
4.query:为loaders提供额外的设置选项
在配置loader之前，我们把Greeter.js里的问候信息放在一个单独json文件里，并通过合适的配置使Greeter.js可以读取该JSON文件的值，各文件修改后的代码如下：
在app文件夹中创建带有问候信息的JSON文件（命名为config.json）
{
        "greetText": "Hi there and greetings from JSON!"
}
更新后的Greetr.js
var config = require("./config,json");
module.exports = functin(){
        var greet = document.createElement('div');
        greeter.textContent = config.greetText;
        return greet;
}
（* 由于webpack3.*/webpack2.*已经内置可处理JSON文件，这里我们无需再添加webpack1.*需要的json-loader。）
（4）Babel
Babel其实是一个编译JavaScript的平台，它可以编译代码来达到以下目的：
1.可以使用最新的JavaScript代码而不用担心浏览器的兼容问题
2.使用JavaScript的拓展代码，如JSX
Babel的安装与配置
Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpace可以把其不同的包整合在一起使用，对于每一个你需要的
功能或拓展，你都需要安装单独的包（用的最多的是解析ES6的babel-env-preset包和解析JSX的babel-preset-react包）
安装：
npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react
在webpack中配置Babel的方法如下：
module.exports = {
        entry: __dirname + "/app/main.js",
        ourput: {
                path: __dirname + "public"
                filename:"bundle.js"
        },
        devtool: 'eval-source-map',
        devServe:{
                contentBase: "./public",
                historyApiFallback: true,
                inline: true
        },
        module:{
                rules:[
                        {
                                test: /(\.jsx|\.js)$/,
                                use:{
                                        loader: "babel-loader",
                                        options:{
                                                presets:[
                                                        "env","react"
                                                ]
                                         }
                                 },
                                 exclude:/node_modules/
                        }
                ]
        }
}
